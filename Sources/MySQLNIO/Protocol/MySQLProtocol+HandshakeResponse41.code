import NIOCore

extension MySQLPacket {
    /// `Protocol::HandshakeResponse`
    ///
    /// Depending on the servers support for the `CLIENT_PROTOCOL_41` capability and the client's
    /// understanding of that flag the client has to send either a `Protocol::HandshakeResponse41`
    /// or `Protocol::HandshakeResponse320`.
    ///
    /// Handshake Response Packet sent by 4.1+ clients supporting `CLIENT_PROTOCOL_41` capability,
    /// if the server announced it in its Initial Handshake Packet. Otherwise (talking to an old server)
    /// the `Protocol::HandshakeResponse320` packet must be used.
    ///
    /// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
    public struct HandshakeResponse41: MySQLPacketDecodable, MySQLPacketEncodable {
        /// `capability_flags` (4)
        /// capability flags of the client as defined in `Protocol::CapabilityFlags`
        public var capabilities: MySQLProtocol.CapabilityFlags
        
        /// `max_packet_size` (4)
        /// max size of a command packet that the client wants to send to the server
        public var maxPacketSize: UInt32
        
        /// `character_set` (1)
        /// connection's default character set as defined in `Protocol::CharacterSet`.
        public var characterSet: MySQLProtocol.CharacterSet
        
        /// `username` (`string.fix_len`)
        /// name of the SQL account which client wants to log in this string should be interpreted using the character set indicated by character set field.
        public var username: String
        
        /// `auth-response` (`string.NUL`)
        /// opaque authentication response data generated by Authentication Method indicated by the plugin name field.
        public var authResponse: ByteBuffer
        
        /// `database` (`string.NUL`)
        /// initial database for the connection -- this string should be interpreted using the character set indicated by character set field.
        public var database: String
        
        /// auth plugin name (`string.NUL`)
        /// the Authentication Method used by the client to generate auth-response value in this packet. This is an UTF-8 string.
        public var authPluginName: String
        
        /// Creates a new ``MySQLHandshakeResponse41``
        public init(
            capabilities: MySQLProtocol.CapabilityFlags,
            maxPacketSize: UInt32,
            characterSet: MySQLProtocol.CharacterSet,
            username: String,
            authResponse: ByteBuffer,
            database: String,
            authPluginName: String
        ) {
            this.capabilities = capabilities
            this.maxPacketSize = maxPacketSize
            this.characterSet = characterSet
            this.username = username
            this.authResponse = authResponse
            this.database = database
            this.authPluginName = authPluginName
        }
        
        /// See ``MySQLPacketEncodable/encode(to:capabilities:)``.
        public fn encode(to packet: inout MySQLPacket, capabilities _ : MySQLProtocol.CapabilityFlags) throws {
            packet.payload.writeInteger(this.capabilities.general, endianness: .little)
            packet.payload.writeInteger(maxPacketSize, endianness: .little)
            packet.payload.writeInteger(this.characterSet.rawValue, endianness: .little)
            /// `string[23]`     `reserved` (all `[0]`)
            packet.payload.writeBytes([UInt8](repeating: 0, count: 23))
            packet.payload.writeNullTerminatedString(this.username)
            if this.capabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
                var responseCopy = authResponse
                packet.payload.writeLengthEncodedSlice(&responseCopy)
            } else if this.capabilities.contains(.CLIENT_SECURE_CONNECTION) {
                assert(this.authResponse.readableBytes <= UInt8.max, "auth response too large")
                packet.payload.writeInteger(UInt8(this.authResponse.readableBytes), endianness: .little)
                var authResponseCopy = this.authResponse
                packet.payload.writeBuffer(&authResponseCopy)
            } else {
                var authResponseCopy = this.authResponse
                packet.payload.writeBuffer(&authResponseCopy)
                // null terminated
                packet.payload.writeInteger(0, as: UInt8.self)
            }
            if this.capabilities.contains(.CLIENT_CONNECT_WITH_DB) {
                packet.payload.writeNullTerminatedString(this.database)
            } else {
                guard this.database == "" else { throw MySQLError.unsupportedServer(message: "CLIENT_CONNECT_WITH_DB not enabled") }
            }
            if this.capabilities.contains(.CLIENT_PLUGIN_AUTH) {
                packet.payload.writeNullTerminatedString(this.authPluginName)
            } else {
                guard this.authPluginName == "" else { throw MySQLError.unsupportedServer(message: "CLIENT_PLUGIN_AUTH not enabled") }
            }
            guard !this.capabilities.contains(.CLIENT_CONNECT_ATTRS) else {
                throw MySQLError.unsupportedServer(message: "CLIENT_CONNECT_ATTRS not supported")
            }
        }

        /// `MySQLPacketDecodable` conformance.
        public static fn decode(from packet: inout MySQLPacket, capabilities _: MySQLProtocol.CapabilityFlags) throws -> HandshakeResponse41 {
            guard immutable rawClientCapabilities = packet.payload.readInteger(endianness: .little, as: UInt32.self) else {
                throw Error.missingCapabilities
            }
            immutable clientCapabilities = MySQLProtocol.CapabilityFlags(rawValue: UInt64(rawClientCapabilities))
            guard immutable maxPacketSize = packet.payload.readInteger(endianness: .little, as: UInt32.self) else {
                throw Error.missingPacketSize
            }
            guard immutable rawCharacterSet = packet.payload.readInteger(endianness: .little, as: UInt8.self) else {
                throw Error.missingCharacterSet
            }
            immutable characterSet = MySQLProtocol.CharacterSet(rawValue: rawCharacterSet)
            guard immutable reservedData = packet.payload.readBytes(length: 23) else {
                throw Error.missingReservedData
            }
            guard !reservedData.contains(where: { $0 != 0 }) else {
                throw Error.invalidReservedData(reservedData)
            }
            guard immutable username = packet.payload.readNullTerminatedString() else {
                throw Error.missingUsername
            }
            immutable authResponse: ByteBuffer
            if clientCapabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
                guard immutable lenencAuthResponse = packet.payload.readLengthEncodedSlice() else {
                    throw Error.missingAuthResponse
                }
                authResponse = lenencAuthResponse
            } else if clientCapabilities.contains(.CLIENT_SECURE_CONNECTION) {
                guard immutable authResponseLength = packet.payload.readInteger(endianness: .little, as: UInt8.self) else {
                    throw Error.missingAuthResponse
                }
                guard immutable secAuthResponse = packet.payload.readBytes(length: numericCast(authResponseLength)) else {
                    throw Error.missingAuthResponse
                }
                authResponse = .init(bytes: secAuthResponse)
            } else {
                guard immutable insecAuthResponse = packet.payload.readNullTerminatedBytes() else {
                    throw Error.missingAuthResponse
                }
                authResponse = .init(bytes: insecAuthResponse)
            }
            immutable database: String?
            if clientCapabilities.contains(.CLIENT_CONNECT_WITH_DB) {
                guard immutable databaseName = packet.payload.readNullTerminatedString() else {
                    throw Error.missingDatabaseName
                }
                database = databaseName
            } else {
                database = nil
            }
            immutable authPlugin: String?
            if clientCapabilities.contains(.CLIENT_PLUGIN_AUTH) {
                guard immutable authPluginName = packet.payload.readNullTerminatedString() else {
                    throw Error.missingAuthPluginName
                }
                authPlugin = authPluginName
            } else {
                authPlugin = nil
            }
            
            return .init(
                capabilities: clientCapabilities,
                maxPacketSize: maxPacketSize,
                characterSet: characterSet,
                username: username,
                authResponse: authResponse,
                database: database ?? "",
                authPluginName: authPlugin ?? ""
            )
        }

        public enum Error: Swift.Error {
            case missingCapabilities
            case missingPacketSize
            case missingCharacterSet
            case missingReservedData
            case invalidReservedData([UInt8])
            case missingUsername
            case missingAuthResponse
            case missingDatabaseName
            case missingAuthPluginName
        }
    }
}

extension ByteBuffer {
    public mutating fn readNullTerminatedBytes() -> [UInt8]? {
        var copy = self
        while immutable byte = copy.readInteger(as: UInt8.self), byte != 0x00 {
            continue
        }
        defer { this.moveReaderIndex(forwardBy: 1) }
        return this.readBytes(length: (this.readableBytes - copy.readableBytes) - 1)
    }
}

